using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Globalization;
using System.Linq;
using System.Reflection;
using System.Text;
using System.Threading;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using MonoMod.SourceGen.Internal;
using MonoMod.SourceGen.Internal.Helpers;

namespace MonoDetour.HookGen
{
    // TODO: finish support for unnameable types

    [Generator]
    public sealed class HookHelperGenerator : IIncrementalGenerator
    {
        // NOTE: keep this in sync with the injected source below
        private enum DetourKind
        {
            Hook = 0,
            ILHook = 1,
            Both = 2,
        }

        public const string GenHelperForTypeAttributeFqn =
            "MonoDetour.HookGen.GenerateHookHelpersAttribute";
        private const string ILHookParameterType = "global::MonoMod.Cil.ILContext.Manipulator";
        public const string GenHelperForTypeAttrFile = "GenerateHookHelpersAttribute.g.cs";
        public const string DelegateTypesFile = "DelegateTypes.g.cs";
        public const string GenHelperForTypeAttributeSource = """
            // <auto-generated />
            #nullable enable

            using System;
            using System.Diagnostics;

            namespace MonoDetour.HookGen {

                internal enum DetourKind {
                    Hook = 0,
                    ILHook = 1,
                    Both = 2,
                }

                internal static class HookGenManager
                {
            #if DEBUG
                    /// <summary>
                    /// The default MonoDetourManager instance used when none is specified.
                    /// </summary>
            #endif
                    internal static global::MonoDetour.MonoDetourManager Instance { get; } = new();
                }

            #if DEBUG
                /// <summary>
                /// Designates a type to generate implicit hook helpers for.
                /// </summary>
                /// <remarks>
                /// Non-public members of the type may or may not be included. It is recommended to use a publicizer with this generator.
                /// </remarks>
            #endif
                [AttributeUsage(AttributeTargets.Assembly, AllowMultiple = true)]
                [Conditional("SOURCE_GENERATOR_ONLY")]
                internal sealed class GenerateHookHelpersAttribute : Attribute {
            #if DEBUG
                    /// <summary>
                    /// The type to generate hook helpers for the members of.
                    /// </summary>
            #endif
                    public Type TargetType { get; }

                    public DetourKind Kind { get; set; } = DetourKind.Hook;

            #if DEBUG
                    /// <summary>
                    /// Whether to generate helpers for nested types. Defaults to <see langword="true"/>.
                    /// </summary>
            #endif
                    public bool IncludeNestedTypes { get; set; } = true;

            #if DEBUG
                    /// <summary>
                    /// Whether to differentiate between overloaded members by putting their (sanitized) signature in the generated name.
                    /// Defaults to <see langword="false"/>.
                    /// </summary>
            #endif
                    public bool DistinguishOverloadsByName { get; set; }

            #if DEBUG
                    /// <summary>
                    /// A list of members to generate hook helpers for in the target type, by exact name.
                    /// All members with the specified names (including overloads) will be generated.
                    /// </summary>
            #endif
                    public string[]? Members { get; set; }

            #if DEBUG
                    /// <summary>
                    /// A list of member name prefixes to match members against. Members whose names have one of these
                    /// prefixes will be included.
                    /// </summary>
            #endif
                    public string[]? MemberNamePrefixes { get; set; }

            #if DEBUG
                    /// <summary>
                    /// A list of member name suffixes to match members against. Members whose names have one of these
                    /// suffixes will be included.
                    /// </summary>
            #endif
                    public string[]? MemberNameSuffixes { get; set; }

            #if DEBUG
                    /// <summary>
                    /// Constructs a <see cref="GenerateHookHelpersAttribute"/> indicating the specified target type.
                    /// </summary>
                    /// <param name="targetType">The type to target for generation.</param>
            #endif
                    public GenerateHookHelpersAttribute(Type targetType) {
                        TargetType = targetType;
                    }
                }
            }
            """;

        private static readonly ObjectPool<
            Dictionary<MetadataReference, ImmutableArrayBuilder<AttributeModel>>
        > asmIdentBuilderDictPool = new(() => new());
        private static readonly ObjectPool<
            Dictionary<TypeContext, ImmutableArrayBuilder<AttributeModel>>
        > typeIdentBuilderDictPool = new(() => new());
        private static readonly ObjectPool<
            Dictionary<(DetourKind, bool, bool), InProgressTypeModel>
        > inProgressTypeModelDictPool = new(() => new());

        private static readonly ObjectPool<HashSet<string>> stringHashSetPool = new(() => new());
        private static readonly ObjectPool<HashSet<MethodSignature>> methodSigHashSetPool = new(
            () => new()
        );
        private static readonly ObjectPool<HashSet<TypeRef>> typeRefHashSetPool = new(() => new());

        private static readonly ObjectPool<Queue<GeneratableTypeModel>> genTypeModelQueuePool = new(
            () => new()
        );

        private static readonly IEqualityComparer<HashSet<string>> stringHashSetEqualityComparer =
            HashSet<string>.CreateSetComparer();

        private sealed record LanguageSupportOptions(
            bool FileLocalTypes,
            bool CollectionExpressions
        );

        private sealed record BclSupportOptions(bool DoesNotReturnAttribute);

        private sealed record ContextSupportOptions(
            LanguageSupportOptions Lang,
            BclSupportOptions Bcl
        );

        private sealed class InProgressTypeModel(
            HashSet<string>? MemberNames,
            HashSet<string>? MemberPrefixes,
            HashSet<string>? MemberSuffixes
        )
        {
            public HashSet<string>? MemberNames { get; set; } = MemberNames;
            public HashSet<string>? MemberPrefixes { get; set; } = MemberPrefixes;
            public HashSet<string>? MemberSuffixes { get; set; } = MemberSuffixes;
        }

        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            context.RegisterPostInitializationOutput(ctx =>
            {
                ctx.AddSource(GenHelperForTypeAttrFile, GenHelperForTypeAttributeSource);
            });

            var langSupport = context.ParseOptionsProvider.Select(
                (options, ct) =>
                {
                    var csOpts = (CSharpParseOptions)options;
                    var langVer = csOpts.LanguageVersion;
                    return new LanguageSupportOptions(
                        langVer >= LanguageVersion.CSharp11,
                        langVer >= LanguageVersion.CSharp12
                    );
                }
            );

            var bclSupport = context.CompilationProvider.Select(
                (c, ct) =>
                {
                    return new BclSupportOptions(
                        c.GetTypeByMetadataName(
                            "System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute"
                        )
                            is not null
                    );
                }
            );

            var support = langSupport
                .Combine(bclSupport)
                .Select((t, ct) => new ContextSupportOptions(t.Left, t.Right));

            var attributes = context
                .SyntaxProvider.ForAttributeWithMetadataName(
                    GenHelperForTypeAttributeFqn,
                    static (_, _) => true,
                    static (ctx, ct) =>
                    {
                        using var builder = ImmutableArrayBuilder<AttributeModel>.Rent();

                        foreach (var attr in ctx.Attributes)
                        {
                            ct.ThrowIfCancellationRequested();
                            var model = ReadTypeModelForAttribute(
                                ctx.SemanticModel.Compilation,
                                ctx.TargetSymbol,
                                attr
                            );
                            if (model is not null)
                            {
                                builder.Add(model);
                            }
                        }

                        return builder.ToImmutable();
                    }
                )
                .SelectMany(static (x, _) => x);

            // all attributes are now available, we now want to group them by target assembly and target type
            var groupedByAssembly = attributes
                .Collect()
                .SelectMany(
                    (attrs, ct) =>
                    {
                        var dict = asmIdentBuilderDictPool.Allocate();

                        foreach (var attr in attrs)
                        {
                            ct.ThrowIfCancellationRequested();

                            if (!dict.TryGetValue(attr.TargetAssembly, out var asmBuilder))
                            {
                                dict.Add(
                                    attr.TargetAssembly,
                                    asmBuilder = ImmutableArrayBuilder<AttributeModel>.Rent()
                                );
                            }

                            asmBuilder.Add(attr);
                        }

                        using var builder = ImmutableArrayBuilder<(
                            MetadataReference Assembly,
                            EquatableArray<AttributeModel> Attributes
                        )>.Rent();

                        foreach (var kvp in dict)
                        {
                            ct.ThrowIfCancellationRequested();
                            builder.Add((kvp.Key, kvp.Value.ToImmutable()));
                            kvp.Value.Dispose();
                        }

                        dict.Clear();
                        asmIdentBuilderDictPool.Free(dict);

                        return builder.ToImmutable();
                    }
                );

            // now for each assembly, we want to group by type
            var groupedByType = groupedByAssembly.Select(
                (t, ct) =>
                {
                    var dict = typeIdentBuilderDictPool.Allocate();

                    foreach (var attr in t.Attributes)
                    {
                        ct.ThrowIfCancellationRequested();

                        if (!dict.TryGetValue(attr.TargetType, out var asmBuilder))
                        {
                            dict.Add(
                                attr.TargetType,
                                asmBuilder = ImmutableArrayBuilder<AttributeModel>.Rent()
                            );
                        }

                        asmBuilder.Add(attr);
                    }

                    using var builder = ImmutableArrayBuilder<TypeModel>.Rent();

                    foreach (var kvp in dict)
                    {
                        ct.ThrowIfCancellationRequested();
                        builder.Add(new(kvp.Key, kvp.Value.ToImmutable()));
                        kvp.Value.Dispose();
                    }

                    dict.Clear();
                    typeIdentBuilderDictPool.Free(dict);

                    return new AssemblyModel(t.Assembly, builder.ToImmutable());
                }
            );

            // then, for each type, we want to unify the requested attribute options
            var unifiedGroupedByType = groupedByType.Select(
                (model, ct) =>
                {
                    using var typeModelBuilder = ImmutableArrayBuilder<TypeModel>.Rent();
                    using var attrsBuilder = ImmutableArrayBuilder<AttributeModel>.Rent();

                    foreach (var type in model.Types)
                    {
                        ct.ThrowIfCancellationRequested();
                        var dict = inProgressTypeModelDictPool.Allocate();

                        foreach (var attr in type.Attributes)
                        {
                            var tuple = (
                                attr.Options.Kind,
                                attr.Options.IncludeNested,
                                attr.Options.DistinguishOverloads
                            );
                            if (!dict.TryGetValue(tuple, out var inProgress))
                            {
                                dict.Add(
                                    tuple,
                                    inProgress = new(stringHashSetPool.Allocate(), null, null)
                                );
                            }

                            if (attr.Options.ExplicitMembers is null)
                            {
                                if (inProgress.MemberNames is not null)
                                {
                                    inProgress.MemberNames.Clear();
                                    stringHashSetPool.Free(inProgress.MemberNames);
                                }
                                inProgress.MemberNames = null;
                                if (inProgress.MemberPrefixes is not null)
                                {
                                    inProgress.MemberPrefixes.Clear();
                                    stringHashSetPool.Free(inProgress.MemberPrefixes);
                                }
                                inProgress.MemberPrefixes = null;
                                if (inProgress.MemberSuffixes is not null)
                                {
                                    inProgress.MemberSuffixes.Clear();
                                    stringHashSetPool.Free(inProgress.MemberSuffixes);
                                }
                                inProgress.MemberSuffixes = null;

                                break;
                            }

                            foreach (var name in attr.Options.ExplicitMembers)
                            {
                                _ = (inProgress.MemberNames ??= stringHashSetPool.Allocate()).Add(
                                    name
                                );
                            }
                            foreach (var name in attr.Options.MemberPrefixes)
                            {
                                _ = (
                                    inProgress.MemberPrefixes ??= stringHashSetPool.Allocate()
                                ).Add(name);
                            }
                            foreach (var name in attr.Options.MemberSuffixes)
                            {
                                _ = (
                                    inProgress.MemberSuffixes ??= stringHashSetPool.Allocate()
                                ).Add(name);
                            }
                        }

                        ct.ThrowIfCancellationRequested();

                        attrsBuilder.Clear();
                        foreach (var kvp in dict)
                        {
                            var prefixes = ImmutableArray<string>.Empty;
                            var suffixes = ImmutableArray<string>.Empty;

                            if (kvp.Value.MemberPrefixes is not null)
                            {
                                prefixes = kvp.Value.MemberPrefixes.ToImmutableArray();
                                kvp.Value.MemberPrefixes.Clear();
                                stringHashSetPool.Free(kvp.Value.MemberPrefixes);
                            }
                            if (kvp.Value.MemberSuffixes is not null)
                            {
                                suffixes = kvp.Value.MemberSuffixes.ToImmutableArray();
                                kvp.Value.MemberSuffixes.Clear();
                                stringHashSetPool.Free(kvp.Value.MemberSuffixes);
                            }

                            attrsBuilder.Add(
                                new(
                                    model.Assembly,
                                    type.TargetType,
                                    new(
                                        kvp.Key.Item1,
                                        kvp.Key.Item2,
                                        kvp.Key.Item3,
                                        kvp.Value.MemberNames,
                                        prefixes,
                                        suffixes
                                    )
                                )
                            );
                        }
                        typeModelBuilder.Add(type with { Attributes = attrsBuilder.ToImmutable() });
                        attrsBuilder.Clear();
                        dict.Clear();
                        inProgressTypeModelDictPool.Free(dict);
                    }

                    return model with
                    {
                        Types = typeModelBuilder.ToImmutable(),
                    };
                }
            );

            // next, we want to go per-assembly, and perform the actual member lookups
            var mappedAssemblies = groupedByType
                .Combine(context.CompilationProvider)
                .Select(GetAssemblySymbol)
                .Where(t => t.Symbol is not null);

            var generatableAssemblies = mappedAssemblies.Select(GetAllMembersToGenerate!);

            var signaturesAndTypes = generatableAssemblies.Select(ExtractSignaturesAndTypes);

            var neededSignaturesWithDupes = signaturesAndTypes.SelectMany(
                (t, ct) => t.Item1.AsImmutableArray()
            );

            var neededSignaturesWithoutDupes = neededSignaturesWithDupes
                .Collect()
                .SelectMany(
                    (arr, ct) =>
                    {
                        var set = methodSigHashSetPool.Allocate();

                        foreach (var method in arr)
                        {
                            _ = set.Add(method);
                        }

                        var result = set.ToImmutableArray();
                        set.Clear();
                        methodSigHashSetPool.Free(set);
                        return result;
                    }
                );

            // context.RegisterSourceOutput(neededSignaturesWithoutDupes.Collect(), EmitDelegateTypes);

            var typesWithoutDupes = signaturesAndTypes
                .SelectMany((t, ct) => t.Item2.AsImmutableArray())
                .Collect()
                .SelectMany(
                    (arr, ct) =>
                    {
                        var set = typeRefHashSetPool.Allocate();

                        foreach (var type in arr)
                        {
                            _ = set.Add(type);
                        }

                        var result = set.ToImmutableArray();
                        set.Clear();
                        typeRefHashSetPool.Free(set);
                        return result;
                    }
                );

            var generatableTypes = generatableAssemblies
                .SelectMany((ass, ct) => ass.Types)
                .Combine(support);

            context.RegisterSourceOutput(generatableTypes, EmitHelperTypes);
        }

        private void EmitDelegateTypes(
            SourceProductionContext context,
            ImmutableArray<MethodSignature> signatures
        )
        {
            if (signatures.IsEmpty)
            {
                return;
            }

            var sb = new StringBuilder();
            var cb = new CodeBuilder(sb);

            cb.WriteHeader().WriteLine("namespace MonoMod.HookGen;").WriteLine();

            foreach (var sig in signatures)
            {
                var origName = GetOrigDelegateName(sig);

                var parameters = sig.ParameterTypes.AsImmutableArray();

                // first, emit the orig delelgate
                cb.Write("internal delegate ")
                    .Write(sig.ReturnType.Refness)
                    .Write(sig.ReturnType.FqName)
                    .Write(" ")
                    .Write(origName)
                    .WriteLine("(")
                    .IncreaseIndent();

                if (sig.ThisType is { } thisType)
                {
                    _ = cb.Write(thisType.Refness).Write(thisType.FqName).Write(" @this");

                    if (parameters.Length != 0)
                    {
                        cb.WriteLine(",");
                    }
                }

                for (var i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];

                    _ = cb.Write(param.Refness)
                        .Write(param.FqName)
                        .Write(" arg")
                        .Write(i.ToString(CultureInfo.InvariantCulture));

                    if (i != parameters.Length - 1)
                    {
                        cb.WriteLine(",");
                    }
                }

                cb.WriteLine(");").DecreaseIndent();

                // then, emit the hook delegate
                cb.Write("internal delegate ")
                    .Write(sig.ReturnType.Refness)
                    .Write(sig.ReturnType.FqName)
                    .Write(" ")
                    .Write(GetHookDelegateName(sig))
                    .WriteLine("(")
                    .IncreaseIndent()
                    .Write(origName)
                    .Write(" orig");

                if (sig.ThisType is { } thisType2)
                {
                    _ = cb.WriteLine(",")
                        .Write(thisType2.Refness)
                        .Write(thisType2.FqName)
                        .Write(" @this");
                }

                for (var i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];

                    _ = cb.WriteLine(",")
                        .Write(param.Refness)
                        .Write(param.FqName)
                        .Write(" arg")
                        .Write(i.ToString(CultureInfo.InvariantCulture));
                }

                cb.WriteLine(");").DecreaseIndent();
            }

            context.AddSource(DelegateTypesFile, sb.ToString());
        }

        private void EmitHelperTypes(
            SourceProductionContext context,
            (GeneratableTypeModel, ContextSupportOptions) input
        )
        {
            var (type, ctx) = input;

            var sb = new StringBuilder();
            var cb = new CodeBuilder(sb);

            cb.WriteHeader();

            if (ctx.Lang.FileLocalTypes)
            {
                cb.WriteLine("file static class ThrowHelper").OpenBlock();

                if (ctx.Bcl.DoesNotReturnAttribute)
                {
                    cb.WriteLine(
                        "[global::System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]"
                    );
                }

                cb.WriteLine("public static void ThrowMissingMethod(string type, string method)")
                    .OpenBlock()
                    .WriteLine("throw new global::System.MissingMethodException(type, method);")
                    .CloseBlock();

                if (ctx.Bcl.DoesNotReturnAttribute)
                {
                    cb.WriteLine(
                        "[global::System.Diagnostics.CodeAnalysis.DoesNotReturnAttribute]"
                    );
                }

                cb.WriteLine("public static void ThrowMissingType(string type)")
                    .OpenBlock()
                    .WriteLine(
                        "throw new global::System.Exception($\"Missing Type: '{type}'. This exception should go away by recompiling against latest assembly references.\");"
                    )
                    .CloseBlock();

                cb.CloseBlock();
            }

            if (type.HasHook)
            {
                cb.WriteLine("namespace On").OpenBlock();

                type.Type.AppendEnterContext(cb);

                EmitTypeMembers(type, cb, il: false, ctx);

                type.Type.AppendExitContext(cb);

                cb.CloseBlock().WriteLine();
            }

            // if (type.HasIl)
            // {
            //     cb.WriteLine("namespace IL").OpenBlock();

            //     type.Type.AppendEnterContext(cb, "internal static");

            //     EmitTypeMembers(type, cb, il: true, ctx);

            //     type.Type.AppendExitContext(cb);

            //     cb.CloseBlock().WriteLine();
            // }

            context.AddSource(
                $"{type.AssemblyIdentity.Name}_{type.Type.FullContextName}.g.cs",
                sb.ToString()
            );
        }

        private static void EmitThrowMissing(
            GeneratableTypeModel type,
            GeneratableMemberModel? member,
            CodeBuilder cb,
            ContextSupportOptions ctx,
            bool force = false
        )
        {
            if (force || !ctx.Lang.FileLocalTypes)
            {
                if (member is { })
                {
                    cb.Write("throw new global::System.MissingMethodException(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .Write("\", \"")
                        .Write(member.Name)
                        .WriteLine("\");");
                }
                else
                {
                    cb.Write("throw new global::System.Exception(\"")
                        .Write("Missing Type: '")
                        .Write(type.Type.InnermostType.MdName)
                        .Write(
                            "'. This exception should go away by recompiling against latest assembly references."
                        )
                        .WriteLine("\");");
                }
            }
            else
            {
                if (member is { })
                {
                    cb.Write("ThrowHelper.ThrowMissingMethod(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .Write("\", \"")
                        .Write(member.Name)
                        .WriteLine("\");");
                }
                else
                {
                    cb.Write("ThrowHelper.ThrowMissingType(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .WriteLine("\");");
                }
            }
        }

        private static void EmitTypeMembers(
            GeneratableTypeModel type,
            CodeBuilder cb,
            bool il,
            ContextSupportOptions ctx
        )
        {
            foreach (var member in type.Members)
            {
                if (il)
                {
                    if (member.Kind == DetourKind.Hook)
                    {
                        continue;
                    }
                }
                else
                {
                    if (member.Kind == DetourKind.ILHook)
                    {
                        continue;
                    }
                }

                var bindingFlags = member.Accessibility switch
                {
                    Accessibility.NotApplicable => BindingFlags.NonPublic,
                    Accessibility.Private => BindingFlags.NonPublic,
                    Accessibility.ProtectedAndInternal => BindingFlags.NonPublic,
                    Accessibility.Protected => BindingFlags.NonPublic,
                    Accessibility.Internal => BindingFlags.NonPublic,
                    Accessibility.ProtectedOrInternal => BindingFlags.NonPublic,
                    Accessibility.Public => BindingFlags.Public,
                    _ => BindingFlags.NonPublic,
                };

                bindingFlags |= member.Signature.ThisType is null
                    ? BindingFlags.Static
                    : BindingFlags.Instance;

                var hookType = "global::MonoMod.RuntimeDetour.ILHook";
                var parameterType = il
                    ? ILHookParameterType
                    : "global::MonoMod.HookGen." + GetHookDelegateName(member.Signature);

                cb.Write("internal static class ").Write(SanitizeName(member.Name));

                if (member.HasOverloads || member.DistinguishByName)
                {
                    AppendSignatureIdentifier(cb, member.Signature);
                }
                cb.WriteLine().OpenBlock();

                cb.WriteLine(
                        "[global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]"
                    )
                    .WriteLine("public delegate void MethodParams(ref Params args);");

                cb.WriteLine("public ref struct Params").OpenBlock();

                if (member.Signature.ThisType is { } thisType)
                {
                    cb.Write("public ");

                    if (thisType.FqName.Contains('<'))
                        cb.Write("object");
                    else
                        cb.Write(thisType.FqName);

                    cb.WriteLine(" self;");
                }
                var parameters = member.Signature.ParameterTypes.AsImmutableArray();

                for (var i = 0; i < parameters.Length; i++)
                {
                    var param = parameters[i];
                    cb.Write("public ");

                    if (param.FqName.Contains('<'))
                        cb.Write("object");
                    else
                        cb.Write(param.FqName);

                    cb.Write(' ').Write("arg").Write(i).WriteLine(';');
                }
                cb.CloseBlock();

                cb.Write("public static ")
                    .Write(hookType)
                    .WriteLine(
                        " Prefix(MethodParams args, global::MonoDetour.MonoDetourManager? manager = null) =>"
                    )
                    .IncreaseIndent()
                    .WriteLine(
                        "(manager ?? global::MonoDetour.HookGen.HookGenManager.Instance).HookGenReflectedHook(args, new(global::MonoDetour.DetourType.PrefixDetour));"
                    )
                    .DecreaseIndent();

                cb.Write("public static ")
                    .Write(hookType)
                    .WriteLine(
                        " Postfix(MethodParams args, global::MonoDetour.MonoDetourManager? manager = null) =>"
                    )
                    .IncreaseIndent()
                    .WriteLine(
                        "(manager ?? global::MonoDetour.HookGen.HookGenManager.Instance).HookGenReflectedHook(args, new(global::MonoDetour.DetourType.PostfixDetour));"
                    )
                    .DecreaseIndent();

                cb.Write("public static ")
                    .Write(hookType)
                    .WriteLine(
                        " ILHook(global::MonoMod.Cil.ILContext.Manipulator manipulator, global::MonoDetour.MonoDetourManager? manager = null) =>"
                    )
                    .IncreaseIndent()
                    .WriteLine(
                        "(manager ?? global::MonoDetour.HookGen.HookGenManager.Instance).Hook(Target(), manipulator);"
                    )
                    .DecreaseIndent();

                cb.Write("public static ")
                    .Write("global::System.Reflection.MethodBase")
                    .WriteLine(" Target()")
                    .OpenBlock();

                if (type.Type.InnermostType.FqName.Contains('<'))
                {
                    if (type.Type.InnermostType.AssemblyIdentityName is null)
                        throw new Exception(
                            "type.Type.InnermostType.AssemblyIdentityName is null but it was needed for unspeakable type"
                        );

                    cb.Write("var type = global::System.Type.GetType(\"")
                        .Write(type.Type.InnermostType.MdName)
                        .Write(", ")
                        .Write(type.Type.InnermostType.AssemblyIdentityName)
                        .WriteLine("\");")
                        .Write("if (type is null) ");

                    EmitThrowMissing(type, null, cb, ctx);
                }
                else
                {
                    cb.Write("var type = typeof(")
                        .Write(type.Type.InnermostType.FqName)
                        .WriteLine(");");
                }

                // cb.Write(type.Type.InnermostType.FqName)
                //     .WriteLine(");")
                cb.Write("var method = type.");

                if (member.IsCtor)
                {
                    cb.Write("GetConstructor(");
                }
                else
                {
                    cb.Write("GetMethod(\"").Write(member.Name).Write("\", ");
                }

                cb.Write("(global::System.Reflection.BindingFlags)~0").Write(", null, ");

                EmitOpenArray(cb, ctx, "global::System.Type");

                foreach (var param in member.Signature.ParameterTypes.AsImmutableArray())
                {
                    if (param.FqName.Contains('<'))
                    {
                        if (param.AssemblyIdentityName is null)
                            throw new Exception(
                                "type.Type.InnermostType.AssemblyIdentityName is null but it was needed for unspeakable type"
                            );

                        cb.Write("global::System.Type.GetType(\"")
                            .Write(param.MdName)
                            .Write(", ")
                            .Write(param.AssemblyIdentityName)
                            .Write("\")");
                    }
                    else
                    {
                        cb.Write("typeof(").Write(param.FqName).Write(")");
                    }
                    if (!string.IsNullOrWhiteSpace(param.Refness))
                    {
                        cb.Write(".MakeByRefType()");
                    }
                    cb.WriteLine(",");
                }

                EmitCloseArray(cb, ctx);

                cb.WriteLine(", null);").Write("if (method is null) ");
                EmitThrowMissing(type, member, cb, ctx);
                cb.WriteLine($"return method{(ctx.Bcl.DoesNotReturnAttribute ? "" : "!")};")
                    .CloseBlock();

                cb.CloseBlock();
            }

            foreach (var nested in type.NestedTypes)
            {
                if (il)
                {
                    if (!nested.HasIl)
                    {
                        continue;
                    }
                }
                else
                {
                    if (!nested.HasHook)
                    {
                        continue;
                    }
                }

                cb.Write("internal static ").Write(nested.Type.ContainingTypeDecls[0]).OpenBlock();

                EmitTypeMembers(nested, cb, il, ctx);

                cb.CloseBlock();
            }
        }

        private static void EmitOpenArray(CodeBuilder cb, ContextSupportOptions ctx, string type)
        {
            if (ctx.Lang.CollectionExpressions)
            {
                cb.WriteLine("[").IncreaseIndent();
            }
            else
            {
                cb.Write("new ").Write(type).WriteLine("[]").OpenBlock();
            }
        }

        private static void EmitCloseArray(CodeBuilder cb, ContextSupportOptions ctx)
        {
            if (ctx.Lang.CollectionExpressions)
            {
                cb.DecreaseIndent().Write("]");
            }
            else
            {
                cb.DecreaseIndent().Write("}");
            }
        }

        private static string GetOrigDelegateName(MethodSignature sig)
        {
            return "Orig" + GetHookDelegateName(sig);
        }

        private static readonly ObjectPool<StringBuilder> stringBuilderPool = new(() => new());

        private static string SanitizeRefness(string v) => v.Replace(" ", "_");

        private static string SanitizeMdName(string v) =>
            v.Replace(".", "_").Replace("`", "_").Replace("+", "_");

        private static string GetHookDelegateName(MethodSignature sig)
        {
            var sb = stringBuilderPool.Allocate();

            var parameters = sig.ParameterTypes.AsImmutableArray();
            sb.Append("HookSig_")
                .Append(SanitizeRefness(sig.ReturnType.Refness))
                .Append(SanitizeMdName(sig.ReturnType.MdName))
                .Append('_')
                .Append(parameters.Length);

            if (sig.ThisType is { } thisType)
            {
                _ = sb.Append('_')
                    .Append(SanitizeRefness(thisType.Refness))
                    .Append(SanitizeMdName(thisType.MdName));
            }

            for (var i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];

                _ = sb.Append('_')
                    .Append(SanitizeRefness(param.Refness))
                    .Append(SanitizeMdName(param.MdName));
            }

            var result = sb.ToString();
            sb.Clear();
            stringBuilderPool.Free(sb);
            return result;
        }

        private static void AppendSignatureIdentifier(CodeBuilder cb, MethodSignature sig)
        {
            var parameters = sig.ParameterTypes.AsImmutableArray();
            cb.Write("_")
                .Write(SanitizeRefness(sig.ReturnType.Refness))
                .Write(SanitizeMdName(sig.ReturnType.MdName))
                .Write('_')
                .Write(parameters.Length.ToString(CultureInfo.InvariantCulture));

            if (sig.ThisType is { } thisType)
            {
                _ = cb.Write('_')
                    .Write(SanitizeRefness(thisType.Refness))
                    .Write(SanitizeMdName(thisType.MdName));
            }

            for (var i = 0; i < parameters.Length; i++)
            {
                var param = parameters[i];

                _ = cb.Write('_')
                    .Write(SanitizeRefness(param.Refness))
                    .Write(SanitizeMdName(param.MdName));
            }
        }

        private static (
            EquatableArray<MethodSignature>,
            EquatableArray<TypeRef>
        ) ExtractSignaturesAndTypes(GeneratableAssembly assembly, CancellationToken token)
        {
            var sigSet = methodSigHashSetPool.Allocate();
            var typeSet = typeRefHashSetPool.Allocate();
            var queue = genTypeModelQueuePool.Allocate();

            foreach (var type in assembly.Types)
            {
                queue.Enqueue(type);
            }

            while (queue.Count > 0)
            {
                var type = queue.Dequeue();

                // add to the type set
                _ = typeSet.Add(type.Type.InnermostType.WithRefness());

                foreach (var method in type.Members)
                {
                    if (method.Kind != DetourKind.ILHook)
                    {
                        sigSet.Add(method.Signature);
                    }

                    _ = typeSet.Add(method.Signature.ReturnType.WithRefness());
                    foreach (var p in method.Signature.ParameterTypes)
                    {
                        _ = typeSet.Add(p.WithRefness());
                    }
                }

                foreach (var nested in type.NestedTypes)
                {
                    queue.Enqueue(nested);
                }
            }

            var methodSigs = sigSet.ToImmutableArray();
            var types = typeSet.ToImmutableArray();
            sigSet.Clear();
            typeSet.Clear();
            methodSigHashSetPool.Free(sigSet);
            typeRefHashSetPool.Free(typeSet);
            genTypeModelQueuePool.Free(queue);
            return (methodSigs, types);
        }

        private static bool MetadataReferenceEquals(MetadataReference a, MetadataReference b)
        {
            if (a is CompilationReference ca)
            {
                if (b is CompilationReference cb)
                {
                    return ca.Compilation == cb.Compilation;
                }
                return false;
            }
            return ReferenceEquals(a, b);
        }

        private sealed record AssemblyModel(
            MetadataReference Assembly,
            EquatableArray<TypeModel> Types
        )
        {
            public bool Equals(AssemblyModel other) =>
                MetadataReferenceEquals(Assembly, other.Assembly) && Types.Equals(other.Types);

            public override int GetHashCode()
            {
                var hc = new HashCode();
                if (Assembly is CompilationReference cr)
                {
                    hc.Add(cr.Compilation);
                }
                else
                {
                    hc.Add(Assembly);
                }
                hc.Add(Types);
                return hc.ToHashCode();
            }
        }

        private sealed record TypeModel(
            TypeContext TargetType,
            EquatableArray<AttributeModel> Attributes
        );

        private sealed record AttributeOptions(
            DetourKind Kind,
            bool IncludeNested,
            bool DistinguishOverloads,
            HashSet<string>? ExplicitMembers,
            EquatableArray<string> MemberPrefixes,
            EquatableArray<string> MemberSuffixes
        )
        {
            public bool Equals(AttributeOptions other)
            {
                return Kind == other.Kind
                    && IncludeNested == other.IncludeNested
                    && DistinguishOverloads == other.DistinguishOverloads
                    && MemberPrefixes.Equals(other.MemberPrefixes)
                    && MemberSuffixes.Equals(other.MemberSuffixes)
                    && (
                        (ExplicitMembers is null && other.ExplicitMembers is null)
                        || ExplicitMembers is not null
                            && other.ExplicitMembers is not null
                            && stringHashSetEqualityComparer.Equals(
                                ExplicitMembers,
                                other.ExplicitMembers
                            )
                    );
            }

            public override int GetHashCode()
            {
                var hc = new HashCode();
                hc.Add(Kind);
                hc.Add(IncludeNested);
                hc.Add(DistinguishOverloads);
                hc.Add(MemberPrefixes);
                hc.Add(MemberSuffixes);
                if (ExplicitMembers is not null)
                {
                    hc.Add(stringHashSetEqualityComparer.GetHashCode(ExplicitMembers));
                }
                return hc.ToHashCode();
            }

            public bool MatchesName(string name)
            {
                if (ExplicitMembers is not null && ExplicitMembers.Contains(name))
                {
                    return true;
                }

                foreach (var prefix in MemberPrefixes)
                {
                    if (name.StartsWith(prefix, StringComparison.Ordinal))
                    {
                        return true;
                    }
                }

                foreach (var suffix in MemberSuffixes)
                {
                    if (name.EndsWith(suffix, StringComparison.Ordinal))
                    {
                        return true;
                    }
                }

                return ExplicitMembers is null && MemberPrefixes.IsEmpty && MemberSuffixes.IsEmpty;
            }
        }

        private sealed record AttributeModel(
            MetadataReference TargetAssembly,
            TypeContext TargetType,
            AttributeOptions Options
        )
        {
            public bool Equals(AttributeModel other) =>
                MetadataReferenceEquals(TargetAssembly, other.TargetAssembly)
                && TargetType.Equals(other.TargetType)
                && Options.Equals(other.Options);

            public override int GetHashCode()
            {
                var hc = new HashCode();
                if (TargetAssembly is CompilationReference cr)
                {
                    hc.Add(cr.Compilation);
                }
                else
                {
                    hc.Add(TargetAssembly);
                }
                hc.Add(TargetType);
                hc.Add(Options);
                return hc.ToHashCode();
            }
        }

        private static AttributeModel? ReadTypeModelForAttribute(
            Compilation compilation,
            ISymbol targetSym,
            AttributeData attr
        )
        {
            if (attr.ConstructorArguments is not [{ Value: INamedTypeSymbol targetType }])
                return null;

            var includeNested = true;
            var distinguishOverloads = false;
            var kind = DetourKind.Hook;
            HashSet<string>? explicitMembers = null;
            var memberPrefixes = ImmutableArray<string>.Empty;
            var memberSuffixes = ImmutableArray<string>.Empty;

            foreach (var named in attr.NamedArguments)
            {
                switch (named.Key)
                {
                    case "Kind"
                        when named.Value is { Kind: TypedConstantKind.Enum, Value: int val }:
                        kind = (DetourKind)val;
                        if (
                            kind
                            is not DetourKind.Hook
                                and not DetourKind.ILHook
                                and not DetourKind.Both
                        )
                        {
                            return null;
                        }
                        break;
                    case "IncludeNestedTypes" when named.Value is { Value: bool bval }:
                        includeNested = bval;
                        break;
                    case "DistinguishOverloadsByName" when named.Value is { Value: bool bval }:
                        distinguishOverloads = bval;
                        break;
                    case "Members"
                        when named.Value is { Kind: TypedConstantKind.Array, Values: var values }:
                        explicitMembers = new HashSet<string>(
                            values.Select(c => c.Value as string).Where(s => s is not null)!
                        );
                        break;
                    case "MemberNamePrefixes"
                        when named.Value is { Kind: TypedConstantKind.Array, Values: var values }:
                        memberPrefixes = values
                            .Select(c => c.Value as string)
                            .Where(s => s is not null)
                            .ToImmutableArray()!;
                        break;
                    case "MemberNameSuffixes"
                        when named.Value is { Kind: TypedConstantKind.Array, Values: var values }:
                        memberSuffixes = values
                            .Select(c => c.Value as string)
                            .Where(s => s is not null)
                            .ToImmutableArray()!;
                        break;

                    default:
                        return null;
                }
            }

            var mr = compilation.GetMetadataReference(targetType.ContainingAssembly);
            if (mr is null)
            {
                // presumably, this means it's in this assembly, so we don't care about it
                return null;
            }

            return new(
                mr,
                GenHelpers.CreateTypeContext(targetType, "namespace", SanitizeName),
                new(
                    kind,
                    includeNested,
                    distinguishOverloads,
                    explicitMembers,
                    memberPrefixes,
                    memberSuffixes
                )
            );
        }

        private sealed record GeneratableAssembly(EquatableArray<GeneratableTypeModel> Types);

        private sealed record GeneratableTypeModel(
            AssemblyIdentity AssemblyIdentity,
            TypeContext Type,
            EquatableArray<GeneratableTypeModel> NestedTypes,
            EquatableArray<GeneratableMemberModel> Members,
            bool HasHook,
            bool HasIl,
            bool NameIsSpeakable
        );

        private sealed record MethodSignature(
            TypeRef? ThisType,
            EquatableArray<TypeRef> ParameterTypes,
            TypeRef ReturnType
        );

        private sealed record GeneratableMemberModel(
            string Name,
            MethodSignature Signature,
            bool DistinguishByName,
            bool HasOverloads,
            bool IsCtor,
            Accessibility Accessibility,
            DetourKind Kind
        );

        // I'm OK putting this in the pipeline, because the IAssemblySymbol here will always represent a metadata reference.
        // The symbols for those are reused when possible, as far as I can tell.
        private static (AssemblyModel Model, IAssemblySymbol? Symbol) GetAssemblySymbol(
            (AssemblyModel Left, Compilation Right) tuple,
            CancellationToken token
        )
        {
            var symbol = tuple.Right.GetAssemblyOrModuleSymbol(tuple.Left.Assembly);
            if (symbol is IModuleSymbol module)
            {
                symbol = module.ContainingAssembly;
            }
            if (symbol is not IAssemblySymbol assembly)
            {
                return (tuple.Left, null);
            }
            return (tuple.Left, assembly);
        }

        private static GeneratableAssembly GetAllMembersToGenerate(
            (AssemblyModel Model, IAssemblySymbol Symbol) tuple,
            CancellationToken token
        )
        {
            using var generatableTypesBuilder = ImmutableArrayBuilder<GeneratableTypeModel>.Rent();

            var (model, assembly) = tuple;

            foreach (var type in model.Types)
            {
                var typeSym = assembly.GetTypeByMetadataName(type.TargetType.InnermostType.MdName);
                if (typeSym is null)
                    continue;

                var typeModel = GetTypeModel(type.TargetType, type.Attributes, typeSym, token);
                if (typeModel is not null)
                    generatableTypesBuilder.Add(typeModel);
            }

            return new(generatableTypesBuilder.ToImmutable());
        }

        private static GeneratableTypeModel? GetTypeModel(
            TypeContext typeContext,
            ImmutableArray<AttributeModel> attrModels,
            INamedTypeSymbol type,
            CancellationToken token
        )
        {
            token.ThrowIfCancellationRequested();

            // ignore generic types, they can't be patched reliably
            if (type.IsGenericType)
            {
                return null;
            }

            if (type.IsAnonymousType)
            {
                return null;
            }

            if (type.IsImplicitlyDeclared)
            {
                // TODO: maybe not this?
                return null;
            }

            using var membersBuilder = ImmutableArrayBuilder<GeneratableMemberModel>.Rent();
            using var typesBuilder = ImmutableArrayBuilder<GeneratableTypeModel>.Rent();

            bool hasHook = false,
                hasIl = false;

            // first, process non-type members
            foreach (var member in type.GetMembers())
            {
                if (member.Kind is not SymbolKind.Method or SymbolKind.Property)
                {
                    continue;
                }

                token.ThrowIfCancellationRequested();

                bool? alreadyMatchedWithDistinguishedOverloads = null;
                var hasOverloads = type.GetMembers(member.Name).Length > 1;

                foreach (var attr in attrModels)
                {
                    var options = attr.Options;

                    if (
                        alreadyMatchedWithDistinguishedOverloads is { } matchVal
                        && matchVal == options.DistinguishOverloads
                    )
                    {
                        // we already matched this member with this distinguishOverloads value, skip
                        continue;
                    }

                    if (!options.MatchesName(member.Name))
                    {
                        continue;
                    }

                    GeneratableMemberModel? model = null;

                    // the member matched, do our processing
                    if (member.Kind is SymbolKind.Property)
                    {
                        var prop = (IPropertySymbol)member;

                        if (prop.GetMethod is { } getMethod)
                        {
                            model = GetModelForMember(getMethod, options, hasOverloads);
                        }
                        if (prop.SetMethod is { } setMethod)
                        {
                            model = GetModelForMember(setMethod, options, hasOverloads);
                        }
                    }
                    else if (member.Kind is SymbolKind.Method)
                    {
                        var method = (IMethodSymbol)member;
                        model = GetModelForMember(method, options, hasOverloads);
                    }

                    if (model is not null)
                    {
                        membersBuilder.Add(model);
                        hasHook |= options.Kind != DetourKind.ILHook;
                        hasIl |= options.Kind != DetourKind.Hook;
                    }

                    if (alreadyMatchedWithDistinguishedOverloads is not null)
                    {
                        // we matched with both, no need to continue
                        break;
                    }
                    else
                    {
                        alreadyMatchedWithDistinguishedOverloads = options.DistinguishOverloads;
                    }
                }
            }

            // then, process type members
            foreach (var attr in attrModels)
            {
                var options = attr.Options;

                if (!options.IncludeNested)
                {
                    continue;
                }

                foreach (var nested in type.GetTypeMembers())
                {
                    token.ThrowIfCancellationRequested();

                    if (!options.MatchesName(nested.Name))
                    {
                        continue;
                    }

                    var typeModel = GetTypeModel(
                        GenHelpers.CreateTypeContext(nested, "class", SanitizeName),
                        ImmutableArray.Create(attr),
                        nested,
                        token
                    );
                    if (typeModel is not null)
                    {
                        typesBuilder.Add(typeModel);
                        hasHook |= typeModel.HasHook;
                        hasIl |= typeModel.HasIl;
                    }
                }
            }

            return new(
                type.ContainingAssembly.Identity,
                typeContext,
                typesBuilder.ToImmutable(),
                membersBuilder.ToImmutable(),
                hasHook,
                hasIl,
                type.CanBeReferencedByName
            );
        }

        private static GeneratableMemberModel? GetModelForMember(
            IMethodSymbol method,
            AttributeOptions options,
            bool hasOverloads
        )
        {
            // skip generic methods
            if (method.IsGenericMethod)
            {
                return null;
            }

            if (method.IsAbstract)
            {
                return null;
            }

            using var paramTypeBuilder = ImmutableArrayBuilder<TypeRef>.Rent();

            foreach (var param in method.Parameters)
            {
                paramTypeBuilder.Add(GenHelpers.CreateRef(param));
            }

            var returnType = GenHelpers.CreateRef(
                method.ReturnType,
                GenHelpers.GetRefString(method.RefKind, isReturn: true)
            );

            TypeRef? thisType = null;
            if (!method.IsStatic)
            {
                var refKind = method.ContainingType.IsValueType
                    ? (method.IsReadOnly ? RefKind.RefReadOnly : RefKind.Ref)
                    : RefKind.None;

                thisType = GenHelpers.CreateRef(
                    method.ContainingType,
                    GenHelpers.GetRefString(refKind, false)
                );
            }

            var sig = new MethodSignature(thisType, paramTypeBuilder.ToImmutable(), returnType);

            return new(
                method.Name,
                sig,
                options.DistinguishOverloads && hasOverloads,
                hasOverloads,
                method.MethodKind is MethodKind.Constructor or MethodKind.StaticConstructor,
                method.DeclaredAccessibility,
                options.Kind
            );
        }

        private static string SanitizeName(string name)
        {
            if (string.IsNullOrEmpty(name))
                return string.Empty;

            var result = name.Replace('.', '_')
                .Replace('/', '_')
                .Replace('`', '_')
                .Replace('+', '_')
                .Replace('<', '_')
                .Replace('>', '_')
                .Replace('$', '_');

            /*
            if (result != name) {
                result = "_S_" + result;
            }
            */

            if (result[0] is >= '0' and <= '9')
            {
                result = "@" + result;
            }

            return result;
        }
    }
}
